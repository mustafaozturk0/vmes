/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Khenda Sentinel API
 * Khenda Sentinel API
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration?: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = portableFetch
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name = "RequiredError";
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 *
 * @export
 * @interface CameraDto
 */
export interface CameraDto {
  /**
   *
   * @type {number}
   * @memberof CameraDto
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof CameraDto
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof CameraDto
   */
  url?: string;
}

/**
 *
 * @export
 * @interface CreateCameraDto
 */
export interface CreateCameraDto {
  /**
   *
   * @type {string}
   * @memberof CreateCameraDto
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof CreateCameraDto
   */
  url?: string;
}

/**
 *
 * @export
 * @interface CreateOutputDto
 */
export interface CreateOutputDto {
  /**
   *
   * @type {string}
   * @memberof CreateOutputDto
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof CreateOutputDto
   */
  ip?: string;
}

/**
 *
 * @export
 * @interface CreatePolygonDto
 */
export interface CreatePolygonDto {
  /**
   *
   * @type {number}
   * @memberof CreatePolygonDto
   */
  cameraId?: number;
  /**
   *
   * @type {string}
   * @memberof CreatePolygonDto
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof CreatePolygonDto
   */
  x?: number;
  /**
   *
   * @type {number}
   * @memberof CreatePolygonDto
   */
  y?: number;
  /**
   *
   * @type {string}
   * @memberof CreatePolygonDto
   */
  color?: string;
  /**
   *
   * @type {Array<Array<number>>}
   * @memberof CreatePolygonDto
   */
  points?: Array<Array<number>>;
  /**
   *
   * @type {Array<PolygonConditionPageDto>}
   * @memberof CreatePolygonDto
   */
  conditionPages?: Array<PolygonConditionPageDto>;
}

/**
 *
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
  /**
   *
   * @type {string}
   * @memberof LoginDto
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof LoginDto
   */
  password?: string;
}

/**
 *
 * @export
 * @interface LoginResponseDto
 */
export interface LoginResponseDto {
  /**
   *
   * @type {UserDto}
   * @memberof LoginResponseDto
   */
  user?: UserDto;
  /**
   *
   * @type {string}
   * @memberof LoginResponseDto
   */
  accessToken?: string;
  /**
   *
   * @type {string}
   * @memberof LoginResponseDto
   */
  refreshToken?: string;
}

/**
 *
 * @export
 * @interface OutputDto
 */
export interface OutputDto {
  /**
   *
   * @type {number}
   * @memberof OutputDto
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof OutputDto
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof OutputDto
   */
  ip?: string;
  /**
   *
   * @type {Date}
   * @memberof OutputDto
   */
  lastCheck?: Date;
  /**
   *
   * @type {boolean}
   * @memberof OutputDto
   */
  isActive?: boolean;
}

/**
 *
 * @export
 * @interface PolygonConditionDto
 */
export interface PolygonConditionDto {
  /**
   *
   * @type {number}
   * @memberof PolygonConditionDto
   */
  class?: number;
  /**
   *
   * @type {string}
   * @memberof PolygonConditionDto
   */
  operator?: PolygonConditionDto.OperatorEnum;
  /**
   *
   * @type {number}
   * @memberof PolygonConditionDto
   */
  count?: number;
  /**
   *
   * @type {Array<PolygonSubConditionDto>}
   * @memberof PolygonConditionDto
   */
  subConditions?: Array<PolygonSubConditionDto>;
  /**
   *
   * @type {string}
   * @memberof PolygonConditionDto
   */
  type?: PolygonConditionDto.TypeEnum;
}

/**
 * @export
 * @namespace PolygonConditionDto
 */
export namespace PolygonConditionDto {
  /**
   * @export
   * @enum {string}
   */
  export enum OperatorEnum {
    GreaterThan = <any>">",
    LessThan = <any>"<",
    Equal = <any>"=",
    GreaterThanOrEqualTo = <any>">=",
    LessThanOrEqualTo = <any>"<=",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    Intersect = <any>"intersect",
    Contain = <any>"contain",
  }
}

/**
 *
 * @export
 * @interface PolygonConditionPageDto
 */
export interface PolygonConditionPageDto {
  /**
   *
   * @type {string}
   * @memberof PolygonConditionPageDto
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof PolygonConditionPageDto
   */
  name?: string;
  /**
   *
   * @type {Array<PolygonConditionDto>}
   * @memberof PolygonConditionPageDto
   */
  conditions?: Array<PolygonConditionDto>;
  /**
   *
   * @type {Array<PolygonOutputDto>}
   * @memberof PolygonConditionPageDto
   */
  outputs?: Array<PolygonOutputDto>;
  /**
   *
   * @type {Array<string>}
   * @memberof PolygonConditionPageDto
   */
  outputMails?: Array<string>;
}

/**
 *
 * @export
 * @interface PolygonDto
 */
export interface PolygonDto {
  /**
   *
   * @type {number}
   * @memberof PolygonDto
   */
  id?: number;
  /**
   *
   * @type {number}
   * @memberof PolygonDto
   */
  cameraId?: number;
  /**
   *
   * @type {string}
   * @memberof PolygonDto
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof PolygonDto
   */
  x?: number;
  /**
   *
   * @type {number}
   * @memberof PolygonDto
   */
  y?: number;
  /**
   *
   * @type {string}
   * @memberof PolygonDto
   */
  color?: string;
  /**
   *
   * @type {Array<Array<number>>}
   * @memberof PolygonDto
   */
  points?: Array<Array<number>>;
  /**
   *
   * @type {Array<PolygonConditionPageDto>}
   * @memberof PolygonDto
   */
  conditionPages?: Array<PolygonConditionPageDto>;
}

/**
 *
 * @export
 * @interface PolygonOutputDto
 */
export interface PolygonOutputDto {
  /**
   *
   * @type {number}
   * @memberof PolygonOutputDto
   */
  id?: number;
  /**
   *
   * @type {number}
   * @memberof PolygonOutputDto
   */
  number?: number;
  /**
   *
   * @type {number}
   * @memberof PolygonOutputDto
   */
  duration?: number;
}

/**
 *
 * @export
 * @interface PolygonSubConditionDto
 */
export interface PolygonSubConditionDto {
  /**
   *
   * @type {string}
   * @memberof PolygonSubConditionDto
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof PolygonSubConditionDto
   */
  class?: number;
  /**
   *
   * @type {string}
   * @memberof PolygonSubConditionDto
   */
  operator?: PolygonSubConditionDto.OperatorEnum;
}

/**
 * @export
 * @namespace PolygonSubConditionDto
 */
export namespace PolygonSubConditionDto {
  /**
   * @export
   * @enum {string}
   */
  export enum OperatorEnum {
    With = <any>"with",
    Without = <any>"without",
  }
}

/**
 *
 * @export
 * @interface RecordDto
 */
export interface RecordDto {
  /**
   *
   * @type {number}
   * @memberof RecordDto
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof RecordDto
   */
  conditionId?: string;
  /**
   *
   * @type {Date}
   * @memberof RecordDto
   */
  datetime?: Date;
  /**
   *
   * @type {string}
   * @memberof RecordDto
   */
  path?: string;
}

/**
 *
 * @export
 * @interface RecordImagesResultDto
 */
export interface RecordImagesResultDto {
  /**
   *
   * @type {Array<string>}
   * @memberof RecordImagesResultDto
   */
  images?: Array<string>;
}

/**
 *
 * @export
 * @interface RecordSearchDto
 */
export interface RecordSearchDto {
  /**
   *
   * @type {number}
   * @memberof RecordSearchDto
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof RecordSearchDto
   */
  pageSize?: number;
  /**
   *
   * @type {Date}
   * @memberof RecordSearchDto
   */
  startDate?: Date;
  /**
   *
   * @type {Date}
   * @memberof RecordSearchDto
   */
  endDate?: Date;
  /**
   *
   * @type {string}
   * @memberof RecordSearchDto
   */
  conditionId?: string;
}

/**
 *
 * @export
 * @interface RecordSearchResultDto
 */
export interface RecordSearchResultDto {
  /**
   *
   * @type {number}
   * @memberof RecordSearchResultDto
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof RecordSearchResultDto
   */
  pageSize?: number;
  /**
   *
   * @type {number}
   * @memberof RecordSearchResultDto
   */
  maxPage?: number;
  /**
   *
   * @type {number}
   * @memberof RecordSearchResultDto
   */
  total?: number;
  /**
   *
   * @type {Array<RecordDto>}
   * @memberof RecordSearchResultDto
   */
  records?: Array<RecordDto>;
}

/**
 *
 * @export
 * @interface RefreshDto
 */
export interface RefreshDto {
  /**
   *
   * @type {string}
   * @memberof RefreshDto
   */
  refreshToken?: string;
}

/**
 *
 * @export
 * @interface RefreshResponseDto
 */
export interface RefreshResponseDto {
  /**
   *
   * @type {string}
   * @memberof RefreshResponseDto
   */
  accessToken?: string;
  /**
   *
   * @type {string}
   * @memberof RefreshResponseDto
   */
  refreshToken?: string;
}

/**
 *
 * @export
 * @interface SetFalsePositiveDto
 */
export interface SetFalsePositiveDto {
  /**
   *
   * @type {string}
   * @memberof SetFalsePositiveDto
   */
  filename?: string;
  /**
   *
   * @type {string}
   * @memberof SetFalsePositiveDto
   */
  foldername?: string;
}

/**
 *
 * @export
 * @interface UpdateOutputDto
 */
export interface UpdateOutputDto {
  /**
   *
   * @type {number}
   * @memberof UpdateOutputDto
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof UpdateOutputDto
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateOutputDto
   */
  ip?: string;
}

/**
 *
 * @export
 * @interface UserDto
 */
export interface UserDto {
  /**
   *
   * @type {number}
   * @memberof UserDto
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  username?: string;
}

/**
 *
 * @export
 * @interface YoloClass
 */
export interface YoloClass {
  /**
   *
   * @type {string}
   * @memberof YoloClass
   */
  className?: string;
  /**
   *
   * @type {number}
   * @memberof YoloClass
   */
  classId?: number;
}

/**
 * AuthApi - fetch parameter creator
 * @export
 */
export const AuthApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {LoginDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAuth(payload: LoginDto, options: any = {}): FetchArgs {
      // verify required parameter 'payload' is not null or undefined
      if (payload === null || payload === undefined) {
        throw new RequiredError(
          "payload",
          "Required parameter payload was null or undefined when calling postAuth."
        );
      }
      const localVarPath = `/api/auth/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"LoginDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(payload || {})
        : payload || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {RefreshDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAuthRefresh(payload: RefreshDto, options: any = {}): FetchArgs {
      // verify required parameter 'payload' is not null or undefined
      if (payload === null || payload === undefined) {
        throw new RequiredError(
          "payload",
          "Required parameter payload was null or undefined when calling postAuthRefresh."
        );
      }
      const localVarPath = `/api/auth/refresh`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"RefreshDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(payload || {})
        : payload || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {LoginDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAuth(
      payload: LoginDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<LoginResponseDto> {
      const localVarFetchArgs = AuthApiFetchParamCreator(
        configuration
      ).postAuth(payload, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {RefreshDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAuthRefresh(
      payload: RefreshDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<RefreshResponseDto> {
      const localVarFetchArgs = AuthApiFetchParamCreator(
        configuration
      ).postAuthRefresh(payload, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {LoginDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAuth(payload: LoginDto, options?: any) {
      return AuthApiFp(configuration).postAuth(payload, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {RefreshDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAuthRefresh(payload: RefreshDto, options?: any) {
      return AuthApiFp(configuration).postAuthRefresh(payload, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   *
   * @param {LoginDto} payload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public postAuth(payload: LoginDto, options?: any) {
    return AuthApiFp(this.configuration).postAuth(payload, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {RefreshDto} payload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public postAuthRefresh(payload: RefreshDto, options?: any) {
    return AuthApiFp(this.configuration).postAuthRefresh(payload, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * CameraApi - fetch parameter creator
 * @export
 */
export const CameraApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCameraId(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling deleteCameraId."
        );
      }
      const localVarPath = `/api/camera/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCamera(options: any = {}): FetchArgs {
      const localVarPath = `/api/camera/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCameraId(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getCameraId."
        );
      }
      const localVarPath = `/api/camera/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreateCameraDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCamera(payload: CreateCameraDto, options: any = {}): FetchArgs {
      // verify required parameter 'payload' is not null or undefined
      if (payload === null || payload === undefined) {
        throw new RequiredError(
          "payload",
          "Required parameter payload was null or undefined when calling postCamera."
        );
      }
      const localVarPath = `/api/camera/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"CreateCameraDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(payload || {})
        : payload || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CameraDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putCamera(payload: CameraDto, options: any = {}): FetchArgs {
      // verify required parameter 'payload' is not null or undefined
      if (payload === null || payload === undefined) {
        throw new RequiredError(
          "payload",
          "Required parameter payload was null or undefined when calling putCamera."
        );
      }
      const localVarPath = `/api/camera/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"CameraDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(payload || {})
        : payload || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CameraApi - functional programming interface
 * @export
 */
export const CameraApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCameraId(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CameraDto> {
      const localVarFetchArgs = CameraApiFetchParamCreator(
        configuration
      ).deleteCameraId(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCamera(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CameraDto>> {
      const localVarFetchArgs =
        CameraApiFetchParamCreator(configuration).getCamera(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCameraId(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CameraDto> {
      const localVarFetchArgs = CameraApiFetchParamCreator(
        configuration
      ).getCameraId(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {CreateCameraDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCamera(
      payload: CreateCameraDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CameraDto> {
      const localVarFetchArgs = CameraApiFetchParamCreator(
        configuration
      ).postCamera(payload, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {CameraDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putCamera(
      payload: CameraDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CameraDto> {
      const localVarFetchArgs = CameraApiFetchParamCreator(
        configuration
      ).putCamera(payload, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * CameraApi - factory interface
 * @export
 */
export const CameraApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCameraId(id: number, options?: any) {
      return CameraApiFp(configuration).deleteCameraId(id, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCamera(options?: any) {
      return CameraApiFp(configuration).getCamera(options)(fetch, basePath);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCameraId(id: number, options?: any) {
      return CameraApiFp(configuration).getCameraId(id, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {CreateCameraDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCamera(payload: CreateCameraDto, options?: any) {
      return CameraApiFp(configuration).postCamera(payload, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {CameraDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putCamera(payload: CameraDto, options?: any) {
      return CameraApiFp(configuration).putCamera(payload, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * CameraApi - object-oriented interface
 * @export
 * @class CameraApi
 * @extends {BaseAPI}
 */
export class CameraApi extends BaseAPI {
  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CameraApi
   */
  public deleteCameraId(id: number, options?: any) {
    return CameraApiFp(this.configuration).deleteCameraId(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CameraApi
   */
  public getCamera(options?: any) {
    return CameraApiFp(this.configuration).getCamera(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CameraApi
   */
  public getCameraId(id: number, options?: any) {
    return CameraApiFp(this.configuration).getCameraId(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {CreateCameraDto} payload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CameraApi
   */
  public postCamera(payload: CreateCameraDto, options?: any) {
    return CameraApiFp(this.configuration).postCamera(payload, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {CameraDto} payload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CameraApi
   */
  public putCamera(payload: CameraDto, options?: any) {
    return CameraApiFp(this.configuration).putCamera(payload, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * OutputApi - fetch parameter creator
 * @export
 */
export const OutputApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOutputId(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling deleteOutputId."
        );
      }
      const localVarPath = `/api/output/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOutput(options: any = {}): FetchArgs {
      const localVarPath = `/api/output/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOutputId(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getOutputId."
        );
      }
      const localVarPath = `/api/output/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreateOutputDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postOutput(payload: CreateOutputDto, options: any = {}): FetchArgs {
      // verify required parameter 'payload' is not null or undefined
      if (payload === null || payload === undefined) {
        throw new RequiredError(
          "payload",
          "Required parameter payload was null or undefined when calling postOutput."
        );
      }
      const localVarPath = `/api/output/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"CreateOutputDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(payload || {})
        : payload || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateOutputDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putOutput(payload: UpdateOutputDto, options: any = {}): FetchArgs {
      // verify required parameter 'payload' is not null or undefined
      if (payload === null || payload === undefined) {
        throw new RequiredError(
          "payload",
          "Required parameter payload was null or undefined when calling putOutput."
        );
      }
      const localVarPath = `/api/output/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"UpdateOutputDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(payload || {})
        : payload || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OutputApi - functional programming interface
 * @export
 */
export const OutputApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOutputId(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OutputDto> {
      const localVarFetchArgs = OutputApiFetchParamCreator(
        configuration
      ).deleteOutputId(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOutput(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OutputDto>> {
      const localVarFetchArgs =
        OutputApiFetchParamCreator(configuration).getOutput(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOutputId(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OutputDto> {
      const localVarFetchArgs = OutputApiFetchParamCreator(
        configuration
      ).getOutputId(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {CreateOutputDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postOutput(
      payload: CreateOutputDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OutputDto> {
      const localVarFetchArgs = OutputApiFetchParamCreator(
        configuration
      ).postOutput(payload, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {UpdateOutputDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putOutput(
      payload: UpdateOutputDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OutputDto> {
      const localVarFetchArgs = OutputApiFetchParamCreator(
        configuration
      ).putOutput(payload, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * OutputApi - factory interface
 * @export
 */
export const OutputApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOutputId(id: number, options?: any) {
      return OutputApiFp(configuration).deleteOutputId(id, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOutput(options?: any) {
      return OutputApiFp(configuration).getOutput(options)(fetch, basePath);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOutputId(id: number, options?: any) {
      return OutputApiFp(configuration).getOutputId(id, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {CreateOutputDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postOutput(payload: CreateOutputDto, options?: any) {
      return OutputApiFp(configuration).postOutput(payload, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {UpdateOutputDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putOutput(payload: UpdateOutputDto, options?: any) {
      return OutputApiFp(configuration).putOutput(payload, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * OutputApi - object-oriented interface
 * @export
 * @class OutputApi
 * @extends {BaseAPI}
 */
export class OutputApi extends BaseAPI {
  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutputApi
   */
  public deleteOutputId(id: number, options?: any) {
    return OutputApiFp(this.configuration).deleteOutputId(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutputApi
   */
  public getOutput(options?: any) {
    return OutputApiFp(this.configuration).getOutput(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutputApi
   */
  public getOutputId(id: number, options?: any) {
    return OutputApiFp(this.configuration).getOutputId(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {CreateOutputDto} payload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutputApi
   */
  public postOutput(payload: CreateOutputDto, options?: any) {
    return OutputApiFp(this.configuration).postOutput(payload, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {UpdateOutputDto} payload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutputApi
   */
  public putOutput(payload: UpdateOutputDto, options?: any) {
    return OutputApiFp(this.configuration).putOutput(payload, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * PolygonApi - fetch parameter creator
 * @export
 */
export const PolygonApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePolygonId(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling deletePolygonId."
        );
      }
      const localVarPath = `/api/polygon/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolygon(options: any = {}): FetchArgs {
      const localVarPath = `/api/polygon/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolygonCameraId(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getPolygonCameraId."
        );
      }
      const localVarPath = `/api/polygon/camera/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolygonId(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getPolygonId."
        );
      }
      const localVarPath = `/api/polygon/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreatePolygonDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postPolygon(payload: CreatePolygonDto, options: any = {}): FetchArgs {
      // verify required parameter 'payload' is not null or undefined
      if (payload === null || payload === undefined) {
        throw new RequiredError(
          "payload",
          "Required parameter payload was null or undefined when calling postPolygon."
        );
      }
      const localVarPath = `/api/polygon/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"CreatePolygonDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(payload || {})
        : payload || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {PolygonDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putPolygon(payload: PolygonDto, options: any = {}): FetchArgs {
      // verify required parameter 'payload' is not null or undefined
      if (payload === null || payload === undefined) {
        throw new RequiredError(
          "payload",
          "Required parameter payload was null or undefined when calling putPolygon."
        );
      }
      const localVarPath = `/api/polygon/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"PolygonDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(payload || {})
        : payload || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PolygonApi - functional programming interface
 * @export
 */
export const PolygonApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePolygonId(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<PolygonDto> {
      const localVarFetchArgs = PolygonApiFetchParamCreator(
        configuration
      ).deletePolygonId(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolygon(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PolygonDto>> {
      const localVarFetchArgs =
        PolygonApiFetchParamCreator(configuration).getPolygon(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolygonCameraId(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PolygonDto>> {
      const localVarFetchArgs = PolygonApiFetchParamCreator(
        configuration
      ).getPolygonCameraId(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolygonId(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<PolygonDto> {
      const localVarFetchArgs = PolygonApiFetchParamCreator(
        configuration
      ).getPolygonId(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {CreatePolygonDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postPolygon(
      payload: CreatePolygonDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<PolygonDto> {
      const localVarFetchArgs = PolygonApiFetchParamCreator(
        configuration
      ).postPolygon(payload, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {PolygonDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putPolygon(
      payload: PolygonDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<PolygonDto> {
      const localVarFetchArgs = PolygonApiFetchParamCreator(
        configuration
      ).putPolygon(payload, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * PolygonApi - factory interface
 * @export
 */
export const PolygonApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePolygonId(id: number, options?: any) {
      return PolygonApiFp(configuration).deletePolygonId(id, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolygon(options?: any) {
      return PolygonApiFp(configuration).getPolygon(options)(fetch, basePath);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolygonCameraId(id: number, options?: any) {
      return PolygonApiFp(configuration).getPolygonCameraId(id, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolygonId(id: number, options?: any) {
      return PolygonApiFp(configuration).getPolygonId(id, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {CreatePolygonDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postPolygon(payload: CreatePolygonDto, options?: any) {
      return PolygonApiFp(configuration).postPolygon(payload, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {PolygonDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putPolygon(payload: PolygonDto, options?: any) {
      return PolygonApiFp(configuration).putPolygon(payload, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * PolygonApi - object-oriented interface
 * @export
 * @class PolygonApi
 * @extends {BaseAPI}
 */
export class PolygonApi extends BaseAPI {
  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PolygonApi
   */
  public deletePolygonId(id: number, options?: any) {
    return PolygonApiFp(this.configuration).deletePolygonId(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PolygonApi
   */
  public getPolygon(options?: any) {
    return PolygonApiFp(this.configuration).getPolygon(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PolygonApi
   */
  public getPolygonCameraId(id: number, options?: any) {
    return PolygonApiFp(this.configuration).getPolygonCameraId(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PolygonApi
   */
  public getPolygonId(id: number, options?: any) {
    return PolygonApiFp(this.configuration).getPolygonId(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {CreatePolygonDto} payload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PolygonApi
   */
  public postPolygon(payload: CreatePolygonDto, options?: any) {
    return PolygonApiFp(this.configuration).postPolygon(payload, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {PolygonDto} payload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PolygonApi
   */
  public putPolygon(payload: PolygonDto, options?: any) {
    return PolygonApiFp(this.configuration).putPolygon(payload, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * RecordApi - fetch parameter creator
 * @export
 */
export const RecordApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {number} classId
     * @param {string} filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFalsePositiveDelete(
      classId: number,
      filename: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'classId' is not null or undefined
      if (classId === null || classId === undefined) {
        throw new RequiredError(
          "classId",
          "Required parameter classId was null or undefined when calling deleteFalsePositiveDelete."
        );
      }
      // verify required parameter 'filename' is not null or undefined
      if (filename === null || filename === undefined) {
        throw new RequiredError(
          "filename",
          "Required parameter filename was null or undefined when calling deleteFalsePositiveDelete."
        );
      }
      const localVarPath = `/api/record/false-positive/{class_id}/{filename}`
        .replace(`{${"class_id"}}`, encodeURIComponent(String(classId)))
        .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} classId
     * @param {string} filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFalsePositiveImage(
      classId: number,
      filename: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'classId' is not null or undefined
      if (classId === null || classId === undefined) {
        throw new RequiredError(
          "classId",
          "Required parameter classId was null or undefined when calling getFalsePositiveImage."
        );
      }
      // verify required parameter 'filename' is not null or undefined
      if (filename === null || filename === undefined) {
        throw new RequiredError(
          "filename",
          "Required parameter filename was null or undefined when calling getFalsePositiveImage."
        );
      }
      const localVarPath =
        `/api/record/false-positive-image/{class_id}/{filename}`
          .replace(`{${"class_id"}}`, encodeURIComponent(String(classId)))
          .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} classId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFalsePositiveList(classId: number, options: any = {}): FetchArgs {
      // verify required parameter 'classId' is not null or undefined
      if (classId === null || classId === undefined) {
        throw new RequiredError(
          "classId",
          "Required parameter classId was null or undefined when calling getFalsePositiveList."
        );
      }
      const localVarPath = `/api/record/false-positive/{class_id}`.replace(
        `{${"class_id"}}`,
        encodeURIComponent(String(classId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordId(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getRecordId."
        );
      }
      const localVarPath = `/api/record/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} folder
     * @param {string} filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordImage(
      folder: string,
      filename: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'folder' is not null or undefined
      if (folder === null || folder === undefined) {
        throw new RequiredError(
          "folder",
          "Required parameter folder was null or undefined when calling getRecordImage."
        );
      }
      // verify required parameter 'filename' is not null or undefined
      if (filename === null || filename === undefined) {
        throw new RequiredError(
          "filename",
          "Required parameter filename was null or undefined when calling getRecordImage."
        );
      }
      const localVarPath = `/api/record/image/{folder}/{filename}`
        .replace(`{${"folder"}}`, encodeURIComponent(String(folder)))
        .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordImages(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getRecordImages."
        );
      }
      const localVarPath = `/api/record/images/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordVideo(filename: string, options: any = {}): FetchArgs {
      // verify required parameter 'filename' is not null or undefined
      if (filename === null || filename === undefined) {
        throw new RequiredError(
          "filename",
          "Required parameter filename was null or undefined when calling getRecordVideo."
        );
      }
      const localVarPath = `/api/record/video/{filename}`.replace(
        `{${"filename"}}`,
        encodeURIComponent(String(filename))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {SetFalsePositiveDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postFalsePositive(
      payload: SetFalsePositiveDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'payload' is not null or undefined
      if (payload === null || payload === undefined) {
        throw new RequiredError(
          "payload",
          "Required parameter payload was null or undefined when calling postFalsePositive."
        );
      }
      const localVarPath = `/api/record/false-positive`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"SetFalsePositiveDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(payload || {})
        : payload || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {RecordSearchDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRecord(payload: RecordSearchDto, options: any = {}): FetchArgs {
      // verify required parameter 'payload' is not null or undefined
      if (payload === null || payload === undefined) {
        throw new RequiredError(
          "payload",
          "Required parameter payload was null or undefined when calling postRecord."
        );
      }
      const localVarPath = `/api/record/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"RecordSearchDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(payload || {})
        : payload || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RecordApi - functional programming interface
 * @export
 */
export const RecordApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {number} classId
     * @param {string} filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFalsePositiveDelete(
      classId: number,
      filename: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<RecordImagesResultDto> {
      const localVarFetchArgs = RecordApiFetchParamCreator(
        configuration
      ).deleteFalsePositiveDelete(classId, filename, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {number} classId
     * @param {string} filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFalsePositiveImage(
      classId: number,
      filename: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = RecordApiFetchParamCreator(
        configuration
      ).getFalsePositiveImage(classId, filename, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {number} classId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFalsePositiveList(
      classId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<RecordImagesResultDto> {
      const localVarFetchArgs = RecordApiFetchParamCreator(
        configuration
      ).getFalsePositiveList(classId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordId(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<RecordDto> {
      const localVarFetchArgs = RecordApiFetchParamCreator(
        configuration
      ).getRecordId(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} folder
     * @param {string} filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordImage(
      folder: string,
      filename: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = RecordApiFetchParamCreator(
        configuration
      ).getRecordImage(folder, filename, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordImages(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<RecordImagesResultDto> {
      const localVarFetchArgs = RecordApiFetchParamCreator(
        configuration
      ).getRecordImages(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordVideo(
      filename: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = RecordApiFetchParamCreator(
        configuration
      ).getRecordVideo(filename, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {SetFalsePositiveDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postFalsePositive(
      payload: SetFalsePositiveDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<SetFalsePositiveDto> {
      const localVarFetchArgs = RecordApiFetchParamCreator(
        configuration
      ).postFalsePositive(payload, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {RecordSearchDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRecord(
      payload: RecordSearchDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<RecordSearchResultDto> {
      const localVarFetchArgs = RecordApiFetchParamCreator(
        configuration
      ).postRecord(payload, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * RecordApi - factory interface
 * @export
 */
export const RecordApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {number} classId
     * @param {string} filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFalsePositiveDelete(
      classId: number,
      filename: string,
      options?: any
    ) {
      return RecordApiFp(configuration).deleteFalsePositiveDelete(
        classId,
        filename,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {number} classId
     * @param {string} filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFalsePositiveImage(classId: number, filename: string, options?: any) {
      return RecordApiFp(configuration).getFalsePositiveImage(
        classId,
        filename,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {number} classId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFalsePositiveList(classId: number, options?: any) {
      return RecordApiFp(configuration).getFalsePositiveList(classId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordId(id: number, options?: any) {
      return RecordApiFp(configuration).getRecordId(id, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {string} folder
     * @param {string} filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordImage(folder: string, filename: string, options?: any) {
      return RecordApiFp(configuration).getRecordImage(
        folder,
        filename,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordImages(id: number, options?: any) {
      return RecordApiFp(configuration).getRecordImages(id, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {string} filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordVideo(filename: string, options?: any) {
      return RecordApiFp(configuration).getRecordVideo(filename, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {SetFalsePositiveDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postFalsePositive(payload: SetFalsePositiveDto, options?: any) {
      return RecordApiFp(configuration).postFalsePositive(payload, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {RecordSearchDto} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRecord(payload: RecordSearchDto, options?: any) {
      return RecordApiFp(configuration).postRecord(payload, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * RecordApi - object-oriented interface
 * @export
 * @class RecordApi
 * @extends {BaseAPI}
 */
export class RecordApi extends BaseAPI {
  /**
   *
   * @param {number} classId
   * @param {string} filename
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordApi
   */
  public deleteFalsePositiveDelete(
    classId: number,
    filename: string,
    options?: any
  ) {
    return RecordApiFp(this.configuration).deleteFalsePositiveDelete(
      classId,
      filename,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {number} classId
   * @param {string} filename
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordApi
   */
  public getFalsePositiveImage(
    classId: number,
    filename: string,
    options?: any
  ) {
    return RecordApiFp(this.configuration).getFalsePositiveImage(
      classId,
      filename,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {number} classId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordApi
   */
  public getFalsePositiveList(classId: number, options?: any) {
    return RecordApiFp(this.configuration).getFalsePositiveList(
      classId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordApi
   */
  public getRecordId(id: number, options?: any) {
    return RecordApiFp(this.configuration).getRecordId(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {string} folder
   * @param {string} filename
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordApi
   */
  public getRecordImage(folder: string, filename: string, options?: any) {
    return RecordApiFp(this.configuration).getRecordImage(
      folder,
      filename,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordApi
   */
  public getRecordImages(id: number, options?: any) {
    return RecordApiFp(this.configuration).getRecordImages(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {string} filename
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordApi
   */
  public getRecordVideo(filename: string, options?: any) {
    return RecordApiFp(this.configuration).getRecordVideo(filename, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {SetFalsePositiveDto} payload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordApi
   */
  public postFalsePositive(payload: SetFalsePositiveDto, options?: any) {
    return RecordApiFp(this.configuration).postFalsePositive(payload, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {RecordSearchDto} payload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordApi
   */
  public postRecord(payload: RecordSearchDto, options?: any) {
    return RecordApiFp(this.configuration).postRecord(payload, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * YoloApi - fetch parameter creator
 * @export
 */
export const YoloApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolygon(options: any = {}): FetchArgs {
      const localVarPath = `/api/yolo/list`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("Authorization")
            : configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * YoloApi - functional programming interface
 * @export
 */
export const YoloApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolygon(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<YoloClass>> {
      const localVarFetchArgs =
        YoloApiFetchParamCreator(configuration).getPolygon(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * YoloApi - factory interface
 * @export
 */
export const YoloApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolygon(options?: any) {
      return YoloApiFp(configuration).getPolygon(options)(fetch, basePath);
    },
  };
};

/**
 * YoloApi - object-oriented interface
 * @export
 * @class YoloApi
 * @extends {BaseAPI}
 */
export class YoloApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof YoloApi
   */
  public getPolygon(options?: any) {
    return YoloApiFp(this.configuration).getPolygon(options)(
      this.fetch,
      this.basePath
    );
  }
}
